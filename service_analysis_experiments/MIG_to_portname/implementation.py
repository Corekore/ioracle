import re

######################
#objects I will need
######################

#Parser class
#members (filepaths, regular expressions)
class Parser:
  def __init__(self, filepath):
    self.filepath = filepath
    self.filehandle = open(self.filepath, 'r')
    self.filedata = self.filehandle.read()
    self.filelines = self.filedata.strip().split("\n")

  #parses the input file generated by the jtool scripts and returns addresses of MIG tables. 
  def get_MIG_addresses(self):
    pattern = re.compile("mach_interface\(type\('MIG'\),filePath\('([^']*)'\),address\('([^']*)'\),num_messages\(([0-9]*)\)\)\.")
    mig_table_list = []
    for line in self.filelines:
      match = pattern.match(line)
      if (match is not None): 
	mig_table = Mig_table(match.group(1), match.group(2), match.group(3))
	mig_table_list.append(mig_table)
    return mig_table_list

#MIG table class
class Mig_table:
  def __init__(self, executable, address, num_messages):
    self.executable = executable
    self.address = address
    self.num_messages = num_messages

  def to_string(self):
    output = ""
    output += "executable: " + self.executable + "\n"
    output += "address: " + self.address + "\n"
    output += "num_messages: " + self.num_messages + "\n"
    return output
    
#call_graph object
#members (origin, list of functions)
#built around some origin address (which will happen to be a MIG table in the first script, but the code will likely be used again)

#function object
#members (start, end, xref_from, xref_to, distance from origin, strings)


######################
#functions I will need
######################

#parse MIG table addresses
#input: data file
#output: list of addresses

#build call graphs within threshold
#input: the address of a MIG table
#output: list of function objects with start address, end address, and call distance from table
#//I don't think we need to know the full path of the function, but maybe I should build it anyway?
#//Maybe the function constructor could also call the string extraction function and find the end of the function too.
#//I need to consider more than just calls of functions. Even just a data reference could be an important connection.
#test by building a manual graph from a MIG table (locationd) and compare output of results to manually generated output.

#build function object
#input: start of a function
#output: full function object with all relevant members
#test by manually evaluating a few real functions and comparing output results.

#extract strings referenced by function (use IDA comments to help)
#input: the start and maybe end of a function
#output: all strings referenced in the function added as a value in function object

#parse valid mach ports
#input: data file for detected mach port names
#output: list of mach port names

#find mach ports in call graph
#input: function object with strings
#output: list of mach port names detected

#general pretty printing or prolog printing
#//make sure this aligns with testing.

#sanity checks
##conflict detector
##function distance checker
##valid port name detector
##procexp result checker
